classdef multi_output_GPR_model < handle
%Written by Xinyi Liu and Shannon Danforth, 2022
    
    properties
       X_joint; % The predictor variable, currently limited to one dimension
       Y_joint; % The corresponding nx3 repsonse array
       X_pred; % The predictor for the joint distribution
       offset; % The mean of Y_joint's columns, i.e the mean of each reponse variable
       

       alpha; % KERNAL PARAMETER: alpha is a positive-valued scale-mixture parameter, striking a balance with l.   
       l;     % KERNAL PARAMETER: l is the characteristic length scale, The bigger â„“ is, the less wiggly your random functions are.
       noise; % SYSTEM PARAMETER: noise level (how much noise the estimator think the function has)
       scale; % SYSTEM PARAMETER: weight of K w.r.t the noise
       K_joint; % The covariance matrix generated by the predictor data, the upper-left block, a diag mtrx 
       K_trans; % The lower-left block
       K_pred; % The lower-right block, a diag mtrx
       
       joint_Mu;
       joint_Var; 
       conditional_Mu;
       conditional_Ci;
       
       %%% NEWLY ADDED FOR multi-output model %%%
       B; % this is the symmetric matrix B that reflects the correlation between outputs 
       S; % this is the signal noise matrix
       C_joint;
       C_trans;
       C_pred;
       joint_Ci;
       num_conditional_pts;

       AP;
       height;
       angle;
       
    end
    
    methods
        % constructor
        function obj = multi_output_GPR_model(X_joint, Y_joint, noise, l, alpha, scale, corr_coefs)
            obj.X_joint = X_joint; 
            obj.offset = mean(Y_joint);
            obj.Y_joint = Y_joint - obj.offset;
            
            obj.B = diag(scale); % set B to identity for now
            obj.B(1,2) = corr_coefs(1);obj.B(2,1) = corr_coefs(1);
            obj.B(1,3) = corr_coefs(2);obj.B(3,1) = corr_coefs(2);
            obj.B(2,3) = corr_coefs(3);obj.B(3,2) = corr_coefs(3);
            obj.S = diag(noise);
            obj.scale = scale;
                      
            obj.l = l;
            obj.alpha = alpha;
            obj.noise = noise;
            obj.K_joint = get_covariance_matrix(obj.X_joint, obj.X_joint, obj.l, obj.alpha);
            obj.C_joint = kron(obj.B, obj.K_joint) + kron( obj.S, eye(length(obj.K_joint)));
        end


        function [joint_Mu, joint_Var, joint_Ci] = predict(obj, X_pred, conf_int)
            %This function predicts reponse values given X_pred points.
            obj.X_pred = X_pred;
            obj.K_trans = get_covariance_matrix(obj.X_joint, obj.X_pred, obj.l, obj.alpha);
            obj.C_trans = kron(obj.B, obj.K_trans);
            obj.K_pred = get_covariance_matrix(obj.X_pred, obj.X_pred, obj.l, obj.alpha);
            obj.C_pred = kron(obj.B, obj.K_pred);
            
            y_joint = reshape(obj.Y_joint, [],1);
            y_pred = obj.C_trans.' * (obj.C_joint\y_joint);
            
            obj.joint_Mu = reshape(y_pred,[], 3)+ obj.offset;
            joint_Mu = obj.joint_Mu ;
            sigma = kron(obj.B, obj.K_pred) - obj.C_trans.'* (obj.C_joint \obj.C_trans) ...
                    + kron( obj.S, eye(length(obj.X_pred)));
            
            
            joint_Var = reshape(diag(sigma),[], 3);
            obj.joint_Var = joint_Var;
            alpha_ci = 1 - conf_int/100;

            %weight for confidence interval
            wt = -norminv(alpha_ci/2);
            
            joint_Ci = reshape(sqrt(joint_Var)*wt,[],3);
            obj.joint_Ci = joint_Ci;

        end
        
        function [Mu_cond, Ci] = conditional_predict(obj, full_phase, Y_gt, bp, num_pts, wt )
            %This function takes the completed data and predicts the
            %response given the previous data points and the joint distribution.

            obj.num_conditional_pts = num_pts;
            
            K_cc = get_covariance_matrix(full_phase( max(1, bp - num_pts):bp), full_phase( max(1, bp - num_pts):bp), obj.l, obj.alpha); 
            K_fc = get_covariance_matrix(full_phase( (bp+1):end ) , full_phase( max(1, bp - num_pts):bp), obj.l, obj.alpha);
            K_cf = get_covariance_matrix(full_phase( max(1, bp - num_pts):bp), full_phase( (bp+1):end ) , obj.l, obj.alpha);
            K_ff = get_covariance_matrix(full_phase( (bp+1):end ), full_phase( (bp+1):end ) , obj.l, obj.alpha);
            
            cov_cc = kron(obj.B * 0.09, K_cc) + kron(obj.S * 1e-3, eye(length(K_cc)));
            cov_fc = kron(obj.B* 0.09, K_fc);
            cov_cf = kron(obj.B* 0.09, K_cf);
            cov_ff = kron(obj.B* 0.09, K_ff);
            
            Mu_c = obj.joint_Mu( max(1, bp - num_pts ):bp, : );
            Mu_f = obj.joint_Mu( (bp+1):end, : );
            
            
            mu_c = reshape(Mu_c, [],1);
            mu_f = reshape(Mu_f, [],1);
            y_gt_c = reshape(Y_gt(max(1, bp - num_pts):bp,:) ,[],1);
            
            mu_cond = mu_f + cov_fc*(cov_cc\( y_gt_c - mu_c ));
            Mu_cond = reshape(mu_cond,[], 3);
            
            var = cov_ff - cov_fc*(cov_cc\cov_cf); %This is the conditional covariance matrix
            
            w = diag( sqrt(var) )*wt;
            Ci = reshape(w,[], 3);
            
            
            obj.conditional_Mu = Mu_cond;
            obj.conditional_Ci = Ci;
            
        end    
    end
end